// Code generated by go-swagger; DO NOT EDIT.

package access

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new access API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for access API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateAccessToken(params *CreateAccessTokenParams, opts ...ClientOption) (*CreateAccessTokenOK, error)

	CreateAccessTokenFromTicket(params *CreateAccessTokenFromTicketParams, opts ...ClientOption) (*CreateAccessTokenFromTicketOK, error)

	GetAccessStatus(params *GetAccessStatusParams, opts ...ClientOption) (*GetAccessStatusOK, error)

	GetLoginConfig(params *GetLoginConfigParams, opts ...ClientOption) (*GetLoginConfigOK, error)

	KnoxCallback(params *KnoxCallbackParams, opts ...ClientOption) error

	KnoxLogout(params *KnoxLogoutParams, opts ...ClientOption) error

	KnoxRequest(params *KnoxRequestParams, opts ...ClientOption) error

	LogOut(params *LogOutParams, opts ...ClientOption) (*LogOutOK, error)

	LogOutComplete(params *LogOutCompleteParams, opts ...ClientOption) (*LogOutCompleteOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CreateAccessToken creates a token for accessing the r e s t API via username password

  The token returned is formatted as a JSON Web Token (JWT). The token is base64 encoded and comprised of three parts. The header, the body, and the signature. The expiration of the token is a contained within the body. It is stored in the browser as a cookie, but also returned inthe response body to be stored/used by third party client scripts.
*/
func (a *Client) CreateAccessToken(params *CreateAccessTokenParams, opts ...ClientOption) (*CreateAccessTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAccessTokenParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createAccessToken",
		Method:             "POST",
		PathPattern:        "/access/token",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateAccessTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateAccessTokenOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createAccessToken: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateAccessTokenFromTicket creates a token for accessing the r e s t API via kerberos ticket exchange s p n e g o negotiation

  The token returned is formatted as a JSON Web Token (JWT). The token is base64 encoded and comprised of three parts. The header, the body, and the signature. The expiration of the token is a contained within the body. The token can be used in the Authorization header in the format 'Authorization: Bearer <token>'. It is also stored in the browser as a cookie.
*/
func (a *Client) CreateAccessTokenFromTicket(params *CreateAccessTokenFromTicketParams, opts ...ClientOption) (*CreateAccessTokenFromTicketOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAccessTokenFromTicketParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createAccessTokenFromTicket",
		Method:             "POST",
		PathPattern:        "/access/kerberos",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateAccessTokenFromTicketReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateAccessTokenFromTicketOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createAccessTokenFromTicket: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAccessStatus gets the status the client s access

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) GetAccessStatus(params *GetAccessStatusParams, opts ...ClientOption) (*GetAccessStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccessStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAccessStatus",
		Method:             "GET",
		PathPattern:        "/access",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"*/*"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAccessStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAccessStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAccessStatus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetLoginConfig retrieves the access configuration for this ni fi
*/
func (a *Client) GetLoginConfig(params *GetLoginConfigParams, opts ...ClientOption) (*GetLoginConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLoginConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getLoginConfig",
		Method:             "GET",
		PathPattern:        "/access/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"*/*"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLoginConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetLoginConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLoginConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  KnoxCallback redirects callback URI for processing the result of the apache knox login sequence

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxCallback(params *KnoxCallbackParams, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxCallbackParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "knoxCallback",
		Method:             "GET",
		PathPattern:        "/access/knox/callback",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"*/*"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxCallbackReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
  KnoxLogout performs a logout in the apache knox

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxLogout(params *KnoxLogoutParams, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxLogoutParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "knoxLogout",
		Method:             "GET",
		PathPattern:        "/access/knox/logout",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"*/*"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxLogoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
  KnoxRequest initiates a request to authenticate through apache knox

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) KnoxRequest(params *KnoxRequestParams, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewKnoxRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "knoxRequest",
		Method:             "GET",
		PathPattern:        "/access/knox/request",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"*/*"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &KnoxRequestReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
  LogOut performs a logout for other providers that have been issued a j w t

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) LogOut(params *LogOutParams, opts ...ClientOption) (*LogOutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogOutParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "logOut",
		Method:             "DELETE",
		PathPattern:        "/access/logout",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"*/*"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &LogOutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LogOutOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for logOut: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  LogOutComplete completes the logout sequence by removing the cached logout request and cookie if they existed and redirects to nifi login

  Note: This endpoint is subject to change as NiFi and it's REST API evolve.
*/
func (a *Client) LogOutComplete(params *LogOutCompleteParams, opts ...ClientOption) (*LogOutCompleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogOutCompleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "logOutComplete",
		Method:             "GET",
		PathPattern:        "/access/logout/complete",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"*/*"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &LogOutCompleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LogOutCompleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for logOutComplete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
