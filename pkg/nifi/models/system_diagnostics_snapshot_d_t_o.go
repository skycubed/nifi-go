// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SystemDiagnosticsSnapshotDTO system diagnostics snapshot d t o
//
// swagger:model SystemDiagnosticsSnapshotDTO
type SystemDiagnosticsSnapshotDTO struct {

	// Number of available processors if supported by the underlying system.
	AvailableProcessors int32 `json:"availableProcessors,omitempty"`

	// The content repository storage usage.
	// Unique: true
	ContentRepositoryStorageUsage []*StorageUsageDTO `json:"contentRepositoryStorageUsage"`

	// Number of daemon threads.
	DaemonThreads int32 `json:"daemonThreads,omitempty"`

	// The flowfile repository storage usage.
	FlowFileRepositoryStorageUsage *StorageUsageDTO `json:"flowFileRepositoryStorageUsage,omitempty"`

	// Amount of free heap.
	FreeHeap string `json:"freeHeap,omitempty"`

	// The number of bytes that are allocated to the JVM heap but not currently being used
	FreeHeapBytes int64 `json:"freeHeapBytes,omitempty"`

	// Amount of free non heap.
	FreeNonHeap string `json:"freeNonHeap,omitempty"`

	// Total number of free non-heap bytes available to the JVM
	FreeNonHeapBytes int64 `json:"freeNonHeapBytes,omitempty"`

	// The garbage collection details.
	// Unique: true
	GarbageCollection []*GarbageCollectionDTO `json:"garbageCollection"`

	// Utilization of heap.
	HeapUtilization string `json:"heapUtilization,omitempty"`

	// Maximum size of heap.
	MaxHeap string `json:"maxHeap,omitempty"`

	// The maximum number of bytes that can be used by the JVM
	MaxHeapBytes int64 `json:"maxHeapBytes,omitempty"`

	// Maximum size of non heap.
	MaxNonHeap string `json:"maxNonHeap,omitempty"`

	// The maximum number of bytes that the JVM can use for non-heap purposes
	MaxNonHeapBytes int64 `json:"maxNonHeapBytes,omitempty"`

	// Utilization of non heap.
	NonHeapUtilization string `json:"nonHeapUtilization,omitempty"`

	// The processor load average if supported by the underlying system.
	ProcessorLoadAverage float64 `json:"processorLoadAverage,omitempty"`

	// The provenance repository storage usage.
	// Unique: true
	ProvenanceRepositoryStorageUsage []*StorageUsageDTO `json:"provenanceRepositoryStorageUsage"`

	// When the diagnostics were generated.
	StatsLastRefreshed string `json:"statsLastRefreshed,omitempty"`

	// Total size of heap.
	TotalHeap string `json:"totalHeap,omitempty"`

	// The total number of bytes that are available for the JVM heap to use
	TotalHeapBytes int64 `json:"totalHeapBytes,omitempty"`

	// Total size of non heap.
	TotalNonHeap string `json:"totalNonHeap,omitempty"`

	// Total number of bytes allocated to the JVM not used for heap
	TotalNonHeapBytes int64 `json:"totalNonHeapBytes,omitempty"`

	// Total number of threads.
	TotalThreads int32 `json:"totalThreads,omitempty"`

	// The uptime of the Java virtual machine
	Uptime string `json:"uptime,omitempty"`

	// Amount of used heap.
	UsedHeap string `json:"usedHeap,omitempty"`

	// The number of bytes of JVM heap that are currently being used
	UsedHeapBytes int64 `json:"usedHeapBytes,omitempty"`

	// Amount of use non heap.
	UsedNonHeap string `json:"usedNonHeap,omitempty"`

	// Total number of bytes used by the JVM not in the heap space
	UsedNonHeapBytes int64 `json:"usedNonHeapBytes,omitempty"`

	// The nifi, os, java, and build version information
	VersionInfo *VersionInfoDTO `json:"versionInfo,omitempty"`
}

// Validate validates this system diagnostics snapshot d t o
func (m *SystemDiagnosticsSnapshotDTO) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContentRepositoryStorageUsage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlowFileRepositoryStorageUsage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGarbageCollection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvenanceRepositoryStorageUsage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersionInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) validateContentRepositoryStorageUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentRepositoryStorageUsage) { // not required
		return nil
	}

	if err := validate.UniqueItems("contentRepositoryStorageUsage", "body", m.ContentRepositoryStorageUsage); err != nil {
		return err
	}

	for i := 0; i < len(m.ContentRepositoryStorageUsage); i++ {
		if swag.IsZero(m.ContentRepositoryStorageUsage[i]) { // not required
			continue
		}

		if m.ContentRepositoryStorageUsage[i] != nil {
			if err := m.ContentRepositoryStorageUsage[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentRepositoryStorageUsage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("contentRepositoryStorageUsage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) validateFlowFileRepositoryStorageUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.FlowFileRepositoryStorageUsage) { // not required
		return nil
	}

	if m.FlowFileRepositoryStorageUsage != nil {
		if err := m.FlowFileRepositoryStorageUsage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flowFileRepositoryStorageUsage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flowFileRepositoryStorageUsage")
			}
			return err
		}
	}

	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) validateGarbageCollection(formats strfmt.Registry) error {
	if swag.IsZero(m.GarbageCollection) { // not required
		return nil
	}

	if err := validate.UniqueItems("garbageCollection", "body", m.GarbageCollection); err != nil {
		return err
	}

	for i := 0; i < len(m.GarbageCollection); i++ {
		if swag.IsZero(m.GarbageCollection[i]) { // not required
			continue
		}

		if m.GarbageCollection[i] != nil {
			if err := m.GarbageCollection[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("garbageCollection" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("garbageCollection" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) validateProvenanceRepositoryStorageUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvenanceRepositoryStorageUsage) { // not required
		return nil
	}

	if err := validate.UniqueItems("provenanceRepositoryStorageUsage", "body", m.ProvenanceRepositoryStorageUsage); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvenanceRepositoryStorageUsage); i++ {
		if swag.IsZero(m.ProvenanceRepositoryStorageUsage[i]) { // not required
			continue
		}

		if m.ProvenanceRepositoryStorageUsage[i] != nil {
			if err := m.ProvenanceRepositoryStorageUsage[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provenanceRepositoryStorageUsage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("provenanceRepositoryStorageUsage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) validateVersionInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.VersionInfo) { // not required
		return nil
	}

	if m.VersionInfo != nil {
		if err := m.VersionInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("versionInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("versionInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this system diagnostics snapshot d t o based on the context it is used
func (m *SystemDiagnosticsSnapshotDTO) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContentRepositoryStorageUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlowFileRepositoryStorageUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGarbageCollection(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvenanceRepositoryStorageUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersionInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) contextValidateContentRepositoryStorageUsage(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ContentRepositoryStorageUsage); i++ {

		if m.ContentRepositoryStorageUsage[i] != nil {
			if err := m.ContentRepositoryStorageUsage[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentRepositoryStorageUsage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("contentRepositoryStorageUsage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) contextValidateFlowFileRepositoryStorageUsage(ctx context.Context, formats strfmt.Registry) error {

	if m.FlowFileRepositoryStorageUsage != nil {
		if err := m.FlowFileRepositoryStorageUsage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flowFileRepositoryStorageUsage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flowFileRepositoryStorageUsage")
			}
			return err
		}
	}

	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) contextValidateGarbageCollection(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GarbageCollection); i++ {

		if m.GarbageCollection[i] != nil {
			if err := m.GarbageCollection[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("garbageCollection" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("garbageCollection" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) contextValidateProvenanceRepositoryStorageUsage(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ProvenanceRepositoryStorageUsage); i++ {

		if m.ProvenanceRepositoryStorageUsage[i] != nil {
			if err := m.ProvenanceRepositoryStorageUsage[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provenanceRepositoryStorageUsage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("provenanceRepositoryStorageUsage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SystemDiagnosticsSnapshotDTO) contextValidateVersionInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.VersionInfo != nil {
		if err := m.VersionInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("versionInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("versionInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SystemDiagnosticsSnapshotDTO) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SystemDiagnosticsSnapshotDTO) UnmarshalBinary(b []byte) error {
	var res SystemDiagnosticsSnapshotDTO
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
