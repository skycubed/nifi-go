// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// JVMSystemDiagnosticsSnapshotDTO j VM system diagnostics snapshot d t o
//
// swagger:model JVMSystemDiagnosticsSnapshotDTO
type JVMSystemDiagnosticsSnapshotDTO struct {

	// Information about the Content Repository's usage
	// Unique: true
	ContentRepositoryStorageUsage []*RepositoryUsageDTO `json:"contentRepositoryStorageUsage"`

	// The number of CPU Cores available on the system
	CPUCores int32 `json:"cpuCores,omitempty"`

	// The 1-minute CPU Load Average
	CPULoadAverage float64 `json:"cpuLoadAverage,omitempty"`

	// Information about the FlowFile Repository's usage
	FlowFileRepositoryStorageUsage *RepositoryUsageDTO `json:"flowFileRepositoryStorageUsage,omitempty"`

	// Diagnostic information about the JVM's garbage collections
	GarbageCollectionDiagnostics []*GarbageCollectionDiagnosticsDTO `json:"garbageCollectionDiagnostics"`

	// The maximum number of bytes that the JVM heap is configured to use, as a human-readable value
	MaxHeap string `json:"maxHeap,omitempty"`

	// The maximum number of bytes that the JVM heap is configured to use for heap
	MaxHeapBytes int64 `json:"maxHeapBytes,omitempty"`

	// The maximum number of open file descriptors that are available to each process
	MaxOpenFileDescriptors int64 `json:"maxOpenFileDescriptors,omitempty"`

	// The number of files that are open by the NiFi process
	OpenFileDescriptors int64 `json:"openFileDescriptors,omitempty"`

	// The number of bytes of RAM available on the system as a human-readable value
	PhysicalMemory string `json:"physicalMemory,omitempty"`

	// The number of bytes of RAM available on the system
	PhysicalMemoryBytes int64 `json:"physicalMemoryBytes,omitempty"`

	// Information about the Provenance Repository's usage
	// Unique: true
	ProvenanceRepositoryStorageUsage []*RepositoryUsageDTO `json:"provenanceRepositoryStorageUsage"`
}

// Validate validates this j VM system diagnostics snapshot d t o
func (m *JVMSystemDiagnosticsSnapshotDTO) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContentRepositoryStorageUsage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlowFileRepositoryStorageUsage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGarbageCollectionDiagnostics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvenanceRepositoryStorageUsage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *JVMSystemDiagnosticsSnapshotDTO) validateContentRepositoryStorageUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentRepositoryStorageUsage) { // not required
		return nil
	}

	if err := validate.UniqueItems("contentRepositoryStorageUsage", "body", m.ContentRepositoryStorageUsage); err != nil {
		return err
	}

	for i := 0; i < len(m.ContentRepositoryStorageUsage); i++ {
		if swag.IsZero(m.ContentRepositoryStorageUsage[i]) { // not required
			continue
		}

		if m.ContentRepositoryStorageUsage[i] != nil {
			if err := m.ContentRepositoryStorageUsage[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentRepositoryStorageUsage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("contentRepositoryStorageUsage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *JVMSystemDiagnosticsSnapshotDTO) validateFlowFileRepositoryStorageUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.FlowFileRepositoryStorageUsage) { // not required
		return nil
	}

	if m.FlowFileRepositoryStorageUsage != nil {
		if err := m.FlowFileRepositoryStorageUsage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flowFileRepositoryStorageUsage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flowFileRepositoryStorageUsage")
			}
			return err
		}
	}

	return nil
}

func (m *JVMSystemDiagnosticsSnapshotDTO) validateGarbageCollectionDiagnostics(formats strfmt.Registry) error {
	if swag.IsZero(m.GarbageCollectionDiagnostics) { // not required
		return nil
	}

	for i := 0; i < len(m.GarbageCollectionDiagnostics); i++ {
		if swag.IsZero(m.GarbageCollectionDiagnostics[i]) { // not required
			continue
		}

		if m.GarbageCollectionDiagnostics[i] != nil {
			if err := m.GarbageCollectionDiagnostics[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("garbageCollectionDiagnostics" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("garbageCollectionDiagnostics" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *JVMSystemDiagnosticsSnapshotDTO) validateProvenanceRepositoryStorageUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvenanceRepositoryStorageUsage) { // not required
		return nil
	}

	if err := validate.UniqueItems("provenanceRepositoryStorageUsage", "body", m.ProvenanceRepositoryStorageUsage); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvenanceRepositoryStorageUsage); i++ {
		if swag.IsZero(m.ProvenanceRepositoryStorageUsage[i]) { // not required
			continue
		}

		if m.ProvenanceRepositoryStorageUsage[i] != nil {
			if err := m.ProvenanceRepositoryStorageUsage[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provenanceRepositoryStorageUsage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("provenanceRepositoryStorageUsage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this j VM system diagnostics snapshot d t o based on the context it is used
func (m *JVMSystemDiagnosticsSnapshotDTO) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContentRepositoryStorageUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlowFileRepositoryStorageUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGarbageCollectionDiagnostics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvenanceRepositoryStorageUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *JVMSystemDiagnosticsSnapshotDTO) contextValidateContentRepositoryStorageUsage(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ContentRepositoryStorageUsage); i++ {

		if m.ContentRepositoryStorageUsage[i] != nil {

			if swag.IsZero(m.ContentRepositoryStorageUsage[i]) { // not required
				return nil
			}

			if err := m.ContentRepositoryStorageUsage[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentRepositoryStorageUsage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("contentRepositoryStorageUsage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *JVMSystemDiagnosticsSnapshotDTO) contextValidateFlowFileRepositoryStorageUsage(ctx context.Context, formats strfmt.Registry) error {

	if m.FlowFileRepositoryStorageUsage != nil {

		if swag.IsZero(m.FlowFileRepositoryStorageUsage) { // not required
			return nil
		}

		if err := m.FlowFileRepositoryStorageUsage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flowFileRepositoryStorageUsage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flowFileRepositoryStorageUsage")
			}
			return err
		}
	}

	return nil
}

func (m *JVMSystemDiagnosticsSnapshotDTO) contextValidateGarbageCollectionDiagnostics(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GarbageCollectionDiagnostics); i++ {

		if m.GarbageCollectionDiagnostics[i] != nil {

			if swag.IsZero(m.GarbageCollectionDiagnostics[i]) { // not required
				return nil
			}

			if err := m.GarbageCollectionDiagnostics[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("garbageCollectionDiagnostics" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("garbageCollectionDiagnostics" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *JVMSystemDiagnosticsSnapshotDTO) contextValidateProvenanceRepositoryStorageUsage(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ProvenanceRepositoryStorageUsage); i++ {

		if m.ProvenanceRepositoryStorageUsage[i] != nil {

			if swag.IsZero(m.ProvenanceRepositoryStorageUsage[i]) { // not required
				return nil
			}

			if err := m.ProvenanceRepositoryStorageUsage[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provenanceRepositoryStorageUsage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("provenanceRepositoryStorageUsage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *JVMSystemDiagnosticsSnapshotDTO) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *JVMSystemDiagnosticsSnapshotDTO) UnmarshalBinary(b []byte) error {
	var res JVMSystemDiagnosticsSnapshotDTO
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
