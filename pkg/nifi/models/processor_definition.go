// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProcessorDefinition processor definition
//
// swagger:model ProcessorDefinition
type ProcessorDefinition struct {

	// Indicates if the component has additional details documentation
	AdditionalDetails bool `json:"additionalDetails,omitempty"`

	// The artifact name of the bundle that provides the referenced type.
	Artifact string `json:"artifact,omitempty"`

	// The build metadata for this component
	BuildInfo *BuildInfo `json:"buildInfo,omitempty"`

	// The default bulletin level, such as WARN, INFO, DEBUG, etc.
	DefaultBulletinLevel string `json:"defaultBulletinLevel,omitempty"`

	// The default concurrent tasks for each scheduling strategy.
	DefaultConcurrentTasksBySchedulingStrategy map[string]int32 `json:"defaultConcurrentTasksBySchedulingStrategy,omitempty"`

	// The default penalty duration as a time period, such as "30 sec".
	DefaultPenaltyDuration string `json:"defaultPenaltyDuration,omitempty"`

	// The default scheduling period for each scheduling strategy. The scheduling period is expected to be a time period, such as "30 sec".
	DefaultSchedulingPeriodBySchedulingStrategy map[string]string `json:"defaultSchedulingPeriodBySchedulingStrategy,omitempty"`

	// The default scheduling strategy for the processor.
	DefaultSchedulingStrategy string `json:"defaultSchedulingStrategy,omitempty"`

	// The default yield duration as a time period, such as "1 sec".
	DefaultYieldDuration string `json:"defaultYieldDuration,omitempty"`

	// Whether or not the component has been deprecated
	Deprecated bool `json:"deprecated,omitempty"`

	// If this component has been deprecated, this optional field provides alternatives to use
	// Unique: true
	DeprecationAlternatives []string `json:"deprecationAlternatives"`

	// If this component has been deprecated, this optional field can be used to provide an explanation
	DeprecationReason string `json:"deprecationReason,omitempty"`

	// Describes the dynamic properties supported by this component
	DynamicProperties []*DynamicProperty `json:"dynamicProperties"`

	// If the processor supports dynamic relationships, this describes the dynamic relationship
	DynamicRelationship *DynamicRelationship `json:"dynamicRelationship,omitempty"`

	// Explicit restrictions that indicate a require permission to use the component
	// Unique: true
	ExplicitRestrictions []*Restriction `json:"explicitRestrictions"`

	// The group name of the bundle that provides the referenced type.
	Group string `json:"group,omitempty"`

	// Any input requirements this processor has.
	// Enum: [INPUT_REQUIRED INPUT_ALLOWED INPUT_FORBIDDEN]
	InputRequirement string `json:"inputRequirement,omitempty"`

	// Whether or not this processor should be scheduled only on the primary node in a cluster.
	PrimaryNodeOnly bool `json:"primaryNodeOnly,omitempty"`

	// Descriptions of configuration properties applicable to this component.
	PropertyDescriptors map[string]PropertyDescriptor `json:"propertyDescriptors,omitempty"`

	// If this type represents a provider for an interface, this lists the APIs it implements
	ProvidedAPIImplementations []*DefinedType `json:"providedApiImplementations"`

	// The FlowFile attributes this processor reads
	ReadsAttributes []*Attribute `json:"readsAttributes"`

	// Whether or not the component has a general restriction
	Restricted bool `json:"restricted,omitempty"`

	// An optional description of the general restriction
	RestrictedExplanation string `json:"restrictedExplanation,omitempty"`

	// The names of other component types that may be related
	// Unique: true
	SeeAlso []string `json:"seeAlso"`

	// Whether or not this processor is considered side-effect free. Side-effect free indicate that the processor's operations on FlowFiles can be safely repeated across process sessions.
	SideEffectFree bool `json:"sideEffectFree,omitempty"`

	// Indicates if the component stores state
	Stateful *Stateful `json:"stateful,omitempty"`

	// The supported relationships for this processor.
	SupportedRelationships []*Relationship `json:"supportedRelationships"`

	// The supported scheduling strategies, such as TIME_DRIVER, CRON, or EVENT_DRIVEN.
	SupportedSchedulingStrategies []string `json:"supportedSchedulingStrategies"`

	// Whether or not this processor supports batching. If a Processor uses this annotation, it allows the Framework to batch calls to session commits, as well as allowing the Framework to return the same session multiple times.
	SupportsBatching bool `json:"supportsBatching,omitempty"`

	// Whether or not this component makes use of dynamic (user-set) properties.
	SupportsDynamicProperties bool `json:"supportsDynamicProperties,omitempty"`

	// Whether or not this processor supports dynamic relationships.
	SupportsDynamicRelationships bool `json:"supportsDynamicRelationships,omitempty"`

	// Whether or not this processor supports event driven scheduling. Indicates to the framework that the Processor is eligible to be scheduled to run based on the occurrence of an "Event" (e.g., when a FlowFile is enqueued in an incoming Connection), rather than being triggered periodically.
	SupportsEventDriven bool `json:"supportsEventDriven,omitempty"`

	// Whether or not this component makes use of sensitive dynamic (user-set) properties.
	SupportsSensitiveDynamicProperties bool `json:"supportsSensitiveDynamicProperties,omitempty"`

	// The system resource considerations for the given component
	SystemResourceConsiderations []*SystemResourceConsideration `json:"systemResourceConsiderations"`

	// The tags associated with this type
	// Unique: true
	Tags []string `json:"tags"`

	// Whether or not this processor should be triggered serially (i.e. no concurrent execution).
	TriggerSerially bool `json:"triggerSerially,omitempty"`

	// Whether or not this processor should be triggered when any destination queue has room.
	TriggerWhenAnyDestinationAvailable bool `json:"triggerWhenAnyDestinationAvailable,omitempty"`

	// Whether or not this processor should be triggered when incoming queues are empty.
	TriggerWhenEmpty bool `json:"triggerWhenEmpty,omitempty"`

	// The fully-qualified class type
	// Required: true
	Type *string `json:"type"`

	// The description of the type.
	TypeDescription string `json:"typeDescription,omitempty"`

	// The version of the bundle that provides the referenced type.
	Version string `json:"version,omitempty"`

	// The FlowFile attributes this processor writes/updates
	WritesAttributes []*Attribute `json:"writesAttributes"`
}

// Validate validates this processor definition
func (m *ProcessorDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeprecationAlternatives(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicRelationship(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExplicitRestrictions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputRequirement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePropertyDescriptors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedAPIImplementations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadsAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeeAlso(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStateful(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedRelationships(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSystemResourceConsiderations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWritesAttributes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProcessorDefinition) validateBuildInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.BuildInfo) { // not required
		return nil
	}

	if m.BuildInfo != nil {
		if err := m.BuildInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buildInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("buildInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessorDefinition) validateDeprecationAlternatives(formats strfmt.Registry) error {
	if swag.IsZero(m.DeprecationAlternatives) { // not required
		return nil
	}

	if err := validate.UniqueItems("deprecationAlternatives", "body", m.DeprecationAlternatives); err != nil {
		return err
	}

	return nil
}

func (m *ProcessorDefinition) validateDynamicProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.DynamicProperties) { // not required
		return nil
	}

	for i := 0; i < len(m.DynamicProperties); i++ {
		if swag.IsZero(m.DynamicProperties[i]) { // not required
			continue
		}

		if m.DynamicProperties[i] != nil {
			if err := m.DynamicProperties[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dynamicProperties" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dynamicProperties" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) validateDynamicRelationship(formats strfmt.Registry) error {
	if swag.IsZero(m.DynamicRelationship) { // not required
		return nil
	}

	if m.DynamicRelationship != nil {
		if err := m.DynamicRelationship.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dynamicRelationship")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dynamicRelationship")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessorDefinition) validateExplicitRestrictions(formats strfmt.Registry) error {
	if swag.IsZero(m.ExplicitRestrictions) { // not required
		return nil
	}

	if err := validate.UniqueItems("explicitRestrictions", "body", m.ExplicitRestrictions); err != nil {
		return err
	}

	for i := 0; i < len(m.ExplicitRestrictions); i++ {
		if swag.IsZero(m.ExplicitRestrictions[i]) { // not required
			continue
		}

		if m.ExplicitRestrictions[i] != nil {
			if err := m.ExplicitRestrictions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("explicitRestrictions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("explicitRestrictions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var processorDefinitionTypeInputRequirementPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INPUT_REQUIRED","INPUT_ALLOWED","INPUT_FORBIDDEN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		processorDefinitionTypeInputRequirementPropEnum = append(processorDefinitionTypeInputRequirementPropEnum, v)
	}
}

const (

	// ProcessorDefinitionInputRequirementINPUTREQUIRED captures enum value "INPUT_REQUIRED"
	ProcessorDefinitionInputRequirementINPUTREQUIRED string = "INPUT_REQUIRED"

	// ProcessorDefinitionInputRequirementINPUTALLOWED captures enum value "INPUT_ALLOWED"
	ProcessorDefinitionInputRequirementINPUTALLOWED string = "INPUT_ALLOWED"

	// ProcessorDefinitionInputRequirementINPUTFORBIDDEN captures enum value "INPUT_FORBIDDEN"
	ProcessorDefinitionInputRequirementINPUTFORBIDDEN string = "INPUT_FORBIDDEN"
)

// prop value enum
func (m *ProcessorDefinition) validateInputRequirementEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, processorDefinitionTypeInputRequirementPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProcessorDefinition) validateInputRequirement(formats strfmt.Registry) error {
	if swag.IsZero(m.InputRequirement) { // not required
		return nil
	}

	// value enum
	if err := m.validateInputRequirementEnum("inputRequirement", "body", m.InputRequirement); err != nil {
		return err
	}

	return nil
}

func (m *ProcessorDefinition) validatePropertyDescriptors(formats strfmt.Registry) error {
	if swag.IsZero(m.PropertyDescriptors) { // not required
		return nil
	}

	for k := range m.PropertyDescriptors {

		if err := validate.Required("propertyDescriptors"+"."+k, "body", m.PropertyDescriptors[k]); err != nil {
			return err
		}
		if val, ok := m.PropertyDescriptors[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("propertyDescriptors" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("propertyDescriptors" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) validateProvidedAPIImplementations(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvidedAPIImplementations) { // not required
		return nil
	}

	for i := 0; i < len(m.ProvidedAPIImplementations); i++ {
		if swag.IsZero(m.ProvidedAPIImplementations[i]) { // not required
			continue
		}

		if m.ProvidedAPIImplementations[i] != nil {
			if err := m.ProvidedAPIImplementations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("providedApiImplementations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("providedApiImplementations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) validateReadsAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.ReadsAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.ReadsAttributes); i++ {
		if swag.IsZero(m.ReadsAttributes[i]) { // not required
			continue
		}

		if m.ReadsAttributes[i] != nil {
			if err := m.ReadsAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("readsAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("readsAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) validateSeeAlso(formats strfmt.Registry) error {
	if swag.IsZero(m.SeeAlso) { // not required
		return nil
	}

	if err := validate.UniqueItems("seeAlso", "body", m.SeeAlso); err != nil {
		return err
	}

	return nil
}

func (m *ProcessorDefinition) validateStateful(formats strfmt.Registry) error {
	if swag.IsZero(m.Stateful) { // not required
		return nil
	}

	if m.Stateful != nil {
		if err := m.Stateful.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stateful")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stateful")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessorDefinition) validateSupportedRelationships(formats strfmt.Registry) error {
	if swag.IsZero(m.SupportedRelationships) { // not required
		return nil
	}

	for i := 0; i < len(m.SupportedRelationships); i++ {
		if swag.IsZero(m.SupportedRelationships[i]) { // not required
			continue
		}

		if m.SupportedRelationships[i] != nil {
			if err := m.SupportedRelationships[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supportedRelationships" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supportedRelationships" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) validateSystemResourceConsiderations(formats strfmt.Registry) error {
	if swag.IsZero(m.SystemResourceConsiderations) { // not required
		return nil
	}

	for i := 0; i < len(m.SystemResourceConsiderations); i++ {
		if swag.IsZero(m.SystemResourceConsiderations[i]) { // not required
			continue
		}

		if m.SystemResourceConsiderations[i] != nil {
			if err := m.SystemResourceConsiderations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("systemResourceConsiderations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("systemResourceConsiderations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	if err := validate.UniqueItems("tags", "body", m.Tags); err != nil {
		return err
	}

	return nil
}

func (m *ProcessorDefinition) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *ProcessorDefinition) validateWritesAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.WritesAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.WritesAttributes); i++ {
		if swag.IsZero(m.WritesAttributes[i]) { // not required
			continue
		}

		if m.WritesAttributes[i] != nil {
			if err := m.WritesAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("writesAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("writesAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this processor definition based on the context it is used
func (m *ProcessorDefinition) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDynamicProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDynamicRelationship(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExplicitRestrictions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePropertyDescriptors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvidedAPIImplementations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReadsAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStateful(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupportedRelationships(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemResourceConsiderations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWritesAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProcessorDefinition) contextValidateBuildInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.BuildInfo != nil {

		if swag.IsZero(m.BuildInfo) { // not required
			return nil
		}

		if err := m.BuildInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buildInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("buildInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessorDefinition) contextValidateDynamicProperties(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DynamicProperties); i++ {

		if m.DynamicProperties[i] != nil {

			if swag.IsZero(m.DynamicProperties[i]) { // not required
				return nil
			}

			if err := m.DynamicProperties[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dynamicProperties" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dynamicProperties" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) contextValidateDynamicRelationship(ctx context.Context, formats strfmt.Registry) error {

	if m.DynamicRelationship != nil {

		if swag.IsZero(m.DynamicRelationship) { // not required
			return nil
		}

		if err := m.DynamicRelationship.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dynamicRelationship")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dynamicRelationship")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessorDefinition) contextValidateExplicitRestrictions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExplicitRestrictions); i++ {

		if m.ExplicitRestrictions[i] != nil {

			if swag.IsZero(m.ExplicitRestrictions[i]) { // not required
				return nil
			}

			if err := m.ExplicitRestrictions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("explicitRestrictions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("explicitRestrictions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) contextValidatePropertyDescriptors(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.PropertyDescriptors {

		if val, ok := m.PropertyDescriptors[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) contextValidateProvidedAPIImplementations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ProvidedAPIImplementations); i++ {

		if m.ProvidedAPIImplementations[i] != nil {

			if swag.IsZero(m.ProvidedAPIImplementations[i]) { // not required
				return nil
			}

			if err := m.ProvidedAPIImplementations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("providedApiImplementations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("providedApiImplementations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) contextValidateReadsAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ReadsAttributes); i++ {

		if m.ReadsAttributes[i] != nil {

			if swag.IsZero(m.ReadsAttributes[i]) { // not required
				return nil
			}

			if err := m.ReadsAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("readsAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("readsAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) contextValidateStateful(ctx context.Context, formats strfmt.Registry) error {

	if m.Stateful != nil {

		if swag.IsZero(m.Stateful) { // not required
			return nil
		}

		if err := m.Stateful.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stateful")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stateful")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessorDefinition) contextValidateSupportedRelationships(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SupportedRelationships); i++ {

		if m.SupportedRelationships[i] != nil {

			if swag.IsZero(m.SupportedRelationships[i]) { // not required
				return nil
			}

			if err := m.SupportedRelationships[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supportedRelationships" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supportedRelationships" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) contextValidateSystemResourceConsiderations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SystemResourceConsiderations); i++ {

		if m.SystemResourceConsiderations[i] != nil {

			if swag.IsZero(m.SystemResourceConsiderations[i]) { // not required
				return nil
			}

			if err := m.SystemResourceConsiderations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("systemResourceConsiderations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("systemResourceConsiderations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProcessorDefinition) contextValidateWritesAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.WritesAttributes); i++ {

		if m.WritesAttributes[i] != nil {

			if swag.IsZero(m.WritesAttributes[i]) { // not required
				return nil
			}

			if err := m.WritesAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("writesAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("writesAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProcessorDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProcessorDefinition) UnmarshalBinary(b []byte) error {
	var res ProcessorDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
