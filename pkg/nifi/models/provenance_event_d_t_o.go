// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ProvenanceEventDTO provenance event d t o
//
// swagger:model ProvenanceEventDTO
type ProvenanceEventDTO struct {

	// The alternate identifier uri for the fileflow for the event.
	AlternateIdentifierURI string `json:"alternateIdentifierUri,omitempty"`

	// The attributes of the flowfile for the event.
	Attributes []*AttributeDTO `json:"attributes"`

	// The child uuids for the event.
	ChildUuids []string `json:"childUuids"`

	// The label for the node where the event originated.
	ClusterNodeAddress string `json:"clusterNodeAddress,omitempty"`

	// The identifier for the node where the event originated.
	ClusterNodeID string `json:"clusterNodeId,omitempty"`

	// The id of the component that generated the event.
	ComponentID string `json:"componentId,omitempty"`

	// The name of the component that generated the event.
	ComponentName string `json:"componentName,omitempty"`

	// The type of the component that generated the event.
	ComponentType string `json:"componentType,omitempty"`

	// Whether the input and output content claim is the same.
	ContentEqual bool `json:"contentEqual,omitempty"`

	// The event details.
	Details string `json:"details,omitempty"`

	// The event duration in milliseconds.
	EventDuration int64 `json:"eventDuration,omitempty"`

	// The event id. This is a one up number thats unique per node.
	EventID int64 `json:"eventId,omitempty"`

	// The timestamp of the event.
	EventTime string `json:"eventTime,omitempty"`

	// The type of the event.
	EventType string `json:"eventType,omitempty"`

	// The size of the flowfile for the event.
	FileSize string `json:"fileSize,omitempty"`

	// The size of the flowfile in bytes for the event.
	FileSizeBytes int64 `json:"fileSizeBytes,omitempty"`

	// The uuid of the flowfile for the event.
	FlowFileUUID string `json:"flowFileUuid,omitempty"`

	// The id of the group that the component resides in. If the component is no longer in the flow, the group id will not be set.
	GroupID string `json:"groupId,omitempty"`

	// The event uuid.
	ID string `json:"id,omitempty"`

	// Whether the input content is still available.
	InputContentAvailable bool `json:"inputContentAvailable,omitempty"`

	// The container in which the input content claim lives.
	InputContentClaimContainer string `json:"inputContentClaimContainer,omitempty"`

	// The file size of the input content claim formatted.
	InputContentClaimFileSize string `json:"inputContentClaimFileSize,omitempty"`

	// The file size of the intput content claim in bytes.
	InputContentClaimFileSizeBytes int64 `json:"inputContentClaimFileSizeBytes,omitempty"`

	// The identifier of the input content claim.
	InputContentClaimIdentifier string `json:"inputContentClaimIdentifier,omitempty"`

	// The offset into the input content claim where the flowfiles content begins.
	InputContentClaimOffset int64 `json:"inputContentClaimOffset,omitempty"`

	// The section in which the input content claim lives.
	InputContentClaimSection string `json:"inputContentClaimSection,omitempty"`

	// The duration since the lineage began, in milliseconds.
	LineageDuration int64 `json:"lineageDuration,omitempty"`

	// Whether the output content is still available.
	OutputContentAvailable bool `json:"outputContentAvailable,omitempty"`

	// The container in which the output content claim lives.
	OutputContentClaimContainer string `json:"outputContentClaimContainer,omitempty"`

	// The file size of the output content claim formatted.
	OutputContentClaimFileSize string `json:"outputContentClaimFileSize,omitempty"`

	// The file size of the output content claim in bytes.
	OutputContentClaimFileSizeBytes int64 `json:"outputContentClaimFileSizeBytes,omitempty"`

	// The identifier of the output content claim.
	OutputContentClaimIdentifier string `json:"outputContentClaimIdentifier,omitempty"`

	// The offset into the output content claim where the flowfiles content begins.
	OutputContentClaimOffset int64 `json:"outputContentClaimOffset,omitempty"`

	// The section in which the output content claim lives.
	OutputContentClaimSection string `json:"outputContentClaimSection,omitempty"`

	// The parent uuids for the event.
	ParentUuids []string `json:"parentUuids"`

	// The relationship to which the flowfile was routed if the event is of type ROUTE.
	Relationship string `json:"relationship,omitempty"`

	// Whether or not replay is available.
	ReplayAvailable bool `json:"replayAvailable,omitempty"`

	// Explanation as to why replay is unavailable.
	ReplayExplanation string `json:"replayExplanation,omitempty"`

	// The identifier of the queue/connection from which the flowfile was pulled to genereate this event. May be null if the queue/connection is unknown or the flowfile was generated from this event.
	SourceConnectionIdentifier string `json:"sourceConnectionIdentifier,omitempty"`

	// The source system flowfile id.
	SourceSystemFlowFileID string `json:"sourceSystemFlowFileId,omitempty"`

	// The source/destination system uri if the event was a RECEIVE/SEND.
	TransitURI string `json:"transitUri,omitempty"`
}

// Validate validates this provenance event d t o
func (m *ProvenanceEventDTO) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProvenanceEventDTO) validateAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.Attributes) { // not required
		return nil
	}

	for i := 0; i < len(m.Attributes); i++ {
		if swag.IsZero(m.Attributes[i]) { // not required
			continue
		}

		if m.Attributes[i] != nil {
			if err := m.Attributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this provenance event d t o based on the context it is used
func (m *ProvenanceEventDTO) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProvenanceEventDTO) contextValidateAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Attributes); i++ {

		if m.Attributes[i] != nil {
			if err := m.Attributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProvenanceEventDTO) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProvenanceEventDTO) UnmarshalBinary(b []byte) error {
	var res ProvenanceEventDTO
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
