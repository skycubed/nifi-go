// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProcessGroupDTO process group d t o
//
// swagger:model ProcessGroupDTO
type ProcessGroupDTO struct {

	// The number of active remote ports in the process group.
	ActiveRemotePortCount int32 `json:"activeRemotePortCount,omitempty"`

	// The comments for the process group.
	Comments string `json:"comments,omitempty"`

	// The contents of this process group.
	Contents *FlowSnippetDTO `json:"contents,omitempty"`

	// Default value used in this Process Group for the maximum data size of objects that can be queued before back pressure is applied.
	DefaultBackPressureDataSizeThreshold string `json:"defaultBackPressureDataSizeThreshold,omitempty"`

	// Default value used in this Process Group for the maximum number of objects that can be queued before back pressure is applied.
	DefaultBackPressureObjectThreshold int64 `json:"defaultBackPressureObjectThreshold,omitempty"`

	// The default FlowFile Expiration for this Process Group.
	DefaultFlowFileExpiration string `json:"defaultFlowFileExpiration,omitempty"`

	// The number of disabled components in the process group.
	DisabledCount int32 `json:"disabledCount,omitempty"`

	// The FlowFile Concurrency for this Process Group.
	// Enum: [UNBOUNDED SINGLE_FLOWFILE_PER_NODE SINGLE_BATCH_PER_NODE]
	FlowfileConcurrency string `json:"flowfileConcurrency,omitempty"`

	// The Outbound Policy that is used for determining how FlowFiles should be transferred out of the Process Group.
	// Enum: [STREAM_WHEN_AVAILABLE BATCH_OUTPUT]
	FlowfileOutboundPolicy string `json:"flowfileOutboundPolicy,omitempty"`

	// The id of the component.
	ID string `json:"id,omitempty"`

	// The number of inactive remote ports in the process group.
	InactiveRemotePortCount int32 `json:"inactiveRemotePortCount,omitempty"`

	// The number of input ports in the process group.
	InputPortCount int32 `json:"inputPortCount,omitempty"`

	// The number of invalid components in the process group.
	InvalidCount int32 `json:"invalidCount,omitempty"`

	// The number of local input ports in the process group.
	LocalInputPortCount int32 `json:"localInputPortCount,omitempty"`

	// The number of local output ports in the process group.
	LocalOutputPortCount int32 `json:"localOutputPortCount,omitempty"`

	// The number of locally modified and stale versioned process groups in the process group.
	LocallyModifiedAndStaleCount int32 `json:"locallyModifiedAndStaleCount,omitempty"`

	// The number of locally modified versioned process groups in the process group.
	LocallyModifiedCount int32 `json:"locallyModifiedCount,omitempty"`

	// The name of the process group.
	Name string `json:"name,omitempty"`

	// The number of output ports in the process group.
	OutputPortCount int32 `json:"outputPortCount,omitempty"`

	// The Parameter Context that this Process Group is bound to.
	ParameterContext *ParameterContextReferenceEntity `json:"parameterContext,omitempty"`

	// The id of parent process group of this component if applicable.
	ParentGroupID string `json:"parentGroupId,omitempty"`

	// The position of this component in the UI if applicable.
	Position *PositionDTO `json:"position,omitempty"`

	// The number of public input ports in the process group.
	PublicInputPortCount int32 `json:"publicInputPortCount,omitempty"`

	// The number of public output ports in the process group.
	PublicOutputPortCount int32 `json:"publicOutputPortCount,omitempty"`

	// The number of running components in this process group.
	RunningCount int32 `json:"runningCount,omitempty"`

	// The number of stale versioned process groups in the process group.
	StaleCount int32 `json:"staleCount,omitempty"`

	// The number of stopped components in the process group.
	StoppedCount int32 `json:"stoppedCount,omitempty"`

	// The number of versioned process groups in the process group that are unable to sync to a registry.
	SyncFailureCount int32 `json:"syncFailureCount,omitempty"`

	// The number of up to date versioned process groups in the process group.
	UpToDateCount int32 `json:"upToDateCount,omitempty"`

	// The variables that are configured for the Process Group. Note that this map contains only those variables that are defined on this Process Group and not any variables that are defined in the parent Process Group, etc. I.e., this Map will not contain all variables that are accessible by components in this Process Group by rather only the variables that are defined for this Process Group itself.
	Variables map[string]string `json:"variables,omitempty"`

	// The Version Control information that indicates which Flow Registry, and where in the Flow Registry, this Process Group is tracking to; or null if this Process Group is not under version control
	VersionControlInformation *VersionControlInformationDTO `json:"versionControlInformation,omitempty"`

	// The ID of the corresponding component that is under version control
	VersionedComponentID string `json:"versionedComponentId,omitempty"`
}

// Validate validates this process group d t o
func (m *ProcessGroupDTO) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlowfileConcurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlowfileOutboundPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParameterContext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersionControlInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProcessGroupDTO) validateContents(formats strfmt.Registry) error {
	if swag.IsZero(m.Contents) { // not required
		return nil
	}

	if m.Contents != nil {
		if err := m.Contents.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contents")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("contents")
			}
			return err
		}
	}

	return nil
}

var processGroupDTOTypeFlowfileConcurrencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["UNBOUNDED","SINGLE_FLOWFILE_PER_NODE","SINGLE_BATCH_PER_NODE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		processGroupDTOTypeFlowfileConcurrencyPropEnum = append(processGroupDTOTypeFlowfileConcurrencyPropEnum, v)
	}
}

const (

	// ProcessGroupDTOFlowfileConcurrencyUNBOUNDED captures enum value "UNBOUNDED"
	ProcessGroupDTOFlowfileConcurrencyUNBOUNDED string = "UNBOUNDED"

	// ProcessGroupDTOFlowfileConcurrencySINGLEFLOWFILEPERNODE captures enum value "SINGLE_FLOWFILE_PER_NODE"
	ProcessGroupDTOFlowfileConcurrencySINGLEFLOWFILEPERNODE string = "SINGLE_FLOWFILE_PER_NODE"

	// ProcessGroupDTOFlowfileConcurrencySINGLEBATCHPERNODE captures enum value "SINGLE_BATCH_PER_NODE"
	ProcessGroupDTOFlowfileConcurrencySINGLEBATCHPERNODE string = "SINGLE_BATCH_PER_NODE"
)

// prop value enum
func (m *ProcessGroupDTO) validateFlowfileConcurrencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, processGroupDTOTypeFlowfileConcurrencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProcessGroupDTO) validateFlowfileConcurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.FlowfileConcurrency) { // not required
		return nil
	}

	// value enum
	if err := m.validateFlowfileConcurrencyEnum("flowfileConcurrency", "body", m.FlowfileConcurrency); err != nil {
		return err
	}

	return nil
}

var processGroupDTOTypeFlowfileOutboundPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STREAM_WHEN_AVAILABLE","BATCH_OUTPUT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		processGroupDTOTypeFlowfileOutboundPolicyPropEnum = append(processGroupDTOTypeFlowfileOutboundPolicyPropEnum, v)
	}
}

const (

	// ProcessGroupDTOFlowfileOutboundPolicySTREAMWHENAVAILABLE captures enum value "STREAM_WHEN_AVAILABLE"
	ProcessGroupDTOFlowfileOutboundPolicySTREAMWHENAVAILABLE string = "STREAM_WHEN_AVAILABLE"

	// ProcessGroupDTOFlowfileOutboundPolicyBATCHOUTPUT captures enum value "BATCH_OUTPUT"
	ProcessGroupDTOFlowfileOutboundPolicyBATCHOUTPUT string = "BATCH_OUTPUT"
)

// prop value enum
func (m *ProcessGroupDTO) validateFlowfileOutboundPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, processGroupDTOTypeFlowfileOutboundPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProcessGroupDTO) validateFlowfileOutboundPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.FlowfileOutboundPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateFlowfileOutboundPolicyEnum("flowfileOutboundPolicy", "body", m.FlowfileOutboundPolicy); err != nil {
		return err
	}

	return nil
}

func (m *ProcessGroupDTO) validateParameterContext(formats strfmt.Registry) error {
	if swag.IsZero(m.ParameterContext) { // not required
		return nil
	}

	if m.ParameterContext != nil {
		if err := m.ParameterContext.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parameterContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parameterContext")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessGroupDTO) validatePosition(formats strfmt.Registry) error {
	if swag.IsZero(m.Position) { // not required
		return nil
	}

	if m.Position != nil {
		if err := m.Position.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("position")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("position")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessGroupDTO) validateVersionControlInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.VersionControlInformation) { // not required
		return nil
	}

	if m.VersionControlInformation != nil {
		if err := m.VersionControlInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("versionControlInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("versionControlInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this process group d t o based on the context it is used
func (m *ProcessGroupDTO) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParameterContext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePosition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersionControlInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProcessGroupDTO) contextValidateContents(ctx context.Context, formats strfmt.Registry) error {

	if m.Contents != nil {
		if err := m.Contents.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contents")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("contents")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessGroupDTO) contextValidateParameterContext(ctx context.Context, formats strfmt.Registry) error {

	if m.ParameterContext != nil {
		if err := m.ParameterContext.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parameterContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parameterContext")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessGroupDTO) contextValidatePosition(ctx context.Context, formats strfmt.Registry) error {

	if m.Position != nil {
		if err := m.Position.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("position")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("position")
			}
			return err
		}
	}

	return nil
}

func (m *ProcessGroupDTO) contextValidateVersionControlInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.VersionControlInformation != nil {
		if err := m.VersionControlInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("versionControlInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("versionControlInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProcessGroupDTO) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProcessGroupDTO) UnmarshalBinary(b []byte) error {
	var res ProcessGroupDTO
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
