// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VersionedConnection versioned connection
//
// swagger:model VersionedConnection
type VersionedConnection struct {

	// The object data size threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won't impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.
	BackPressureDataSizeThreshold string `json:"backPressureDataSizeThreshold,omitempty"`

	// The object count threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won't impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.
	BackPressureObjectThreshold int64 `json:"backPressureObjectThreshold,omitempty"`

	// The bend points on the connection.
	Bends []*Position `json:"bends"`

	// The user-supplied comments for the component
	Comments string `json:"comments,omitempty"`

	// component type
	// Enum: [CONNECTION PROCESSOR PROCESS_GROUP REMOTE_PROCESS_GROUP INPUT_PORT OUTPUT_PORT REMOTE_INPUT_PORT REMOTE_OUTPUT_PORT FUNNEL LABEL CONTROLLER_SERVICE]
	ComponentType string `json:"componentType,omitempty"`

	// The destination of the connection.
	Destination *ConnectableComponent `json:"destination,omitempty"`

	// The amount of time a flow file may be in the flow before it will be automatically aged out of the flow. Once a flow file reaches this age it will be terminated from the flow the next time a processor attempts to start work on it.
	FlowFileExpiration string `json:"flowFileExpiration,omitempty"`

	// The ID of the Process Group that this component belongs to
	GroupIdentifier string `json:"groupIdentifier,omitempty"`

	// The component's unique identifier
	Identifier string `json:"identifier,omitempty"`

	// The index of the bend point where to place the connection label.
	LabelIndex int32 `json:"labelIndex,omitempty"`

	// Whether or not compression should be used when transferring FlowFiles between nodes
	// Enum: [DO_NOT_COMPRESS COMPRESS_ATTRIBUTES_ONLY COMPRESS_ATTRIBUTES_AND_CONTENT]
	LoadBalanceCompression string `json:"loadBalanceCompression,omitempty"`

	// The Strategy to use for load balancing data across the cluster, or null, if no Load Balance Strategy has been specified.
	// Enum: [DO_NOT_LOAD_BALANCE PARTITION_BY_ATTRIBUTE ROUND_ROBIN SINGLE_NODE]
	LoadBalanceStrategy string `json:"loadBalanceStrategy,omitempty"`

	// The component's name
	Name string `json:"name,omitempty"`

	// The attribute to use for partitioning data as it is load balanced across the cluster. If the Load Balance Strategy is configured to use PARTITION_BY_ATTRIBUTE, the value returned by this method is the name of the FlowFile Attribute that will be used to determine which node in the cluster should receive a given FlowFile. If the Load Balance Strategy is unset or is set to any other value, the Partitioning Attribute has no effect.
	PartitioningAttribute string `json:"partitioningAttribute,omitempty"`

	// The component's position on the graph
	Position *Position `json:"position,omitempty"`

	// The comparators used to prioritize the queue.
	Prioritizers []string `json:"prioritizers"`

	// The selected relationship that comprise the connection.
	// Unique: true
	SelectedRelationships []string `json:"selectedRelationships"`

	// The source of the connection.
	Source *ConnectableComponent `json:"source,omitempty"`

	// The z index of the connection.
	ZIndex int64 `json:"zIndex,omitempty"`
}

// Validate validates this versioned connection
func (m *VersionedConnection) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBends(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComponentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadBalanceCompression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadBalanceStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelectedRelationships(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VersionedConnection) validateBends(formats strfmt.Registry) error {
	if swag.IsZero(m.Bends) { // not required
		return nil
	}

	for i := 0; i < len(m.Bends); i++ {
		if swag.IsZero(m.Bends[i]) { // not required
			continue
		}

		if m.Bends[i] != nil {
			if err := m.Bends[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bends" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bends" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var versionedConnectionTypeComponentTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CONNECTION","PROCESSOR","PROCESS_GROUP","REMOTE_PROCESS_GROUP","INPUT_PORT","OUTPUT_PORT","REMOTE_INPUT_PORT","REMOTE_OUTPUT_PORT","FUNNEL","LABEL","CONTROLLER_SERVICE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		versionedConnectionTypeComponentTypePropEnum = append(versionedConnectionTypeComponentTypePropEnum, v)
	}
}

const (

	// VersionedConnectionComponentTypeCONNECTION captures enum value "CONNECTION"
	VersionedConnectionComponentTypeCONNECTION string = "CONNECTION"

	// VersionedConnectionComponentTypePROCESSOR captures enum value "PROCESSOR"
	VersionedConnectionComponentTypePROCESSOR string = "PROCESSOR"

	// VersionedConnectionComponentTypePROCESSGROUP captures enum value "PROCESS_GROUP"
	VersionedConnectionComponentTypePROCESSGROUP string = "PROCESS_GROUP"

	// VersionedConnectionComponentTypeREMOTEPROCESSGROUP captures enum value "REMOTE_PROCESS_GROUP"
	VersionedConnectionComponentTypeREMOTEPROCESSGROUP string = "REMOTE_PROCESS_GROUP"

	// VersionedConnectionComponentTypeINPUTPORT captures enum value "INPUT_PORT"
	VersionedConnectionComponentTypeINPUTPORT string = "INPUT_PORT"

	// VersionedConnectionComponentTypeOUTPUTPORT captures enum value "OUTPUT_PORT"
	VersionedConnectionComponentTypeOUTPUTPORT string = "OUTPUT_PORT"

	// VersionedConnectionComponentTypeREMOTEINPUTPORT captures enum value "REMOTE_INPUT_PORT"
	VersionedConnectionComponentTypeREMOTEINPUTPORT string = "REMOTE_INPUT_PORT"

	// VersionedConnectionComponentTypeREMOTEOUTPUTPORT captures enum value "REMOTE_OUTPUT_PORT"
	VersionedConnectionComponentTypeREMOTEOUTPUTPORT string = "REMOTE_OUTPUT_PORT"

	// VersionedConnectionComponentTypeFUNNEL captures enum value "FUNNEL"
	VersionedConnectionComponentTypeFUNNEL string = "FUNNEL"

	// VersionedConnectionComponentTypeLABEL captures enum value "LABEL"
	VersionedConnectionComponentTypeLABEL string = "LABEL"

	// VersionedConnectionComponentTypeCONTROLLERSERVICE captures enum value "CONTROLLER_SERVICE"
	VersionedConnectionComponentTypeCONTROLLERSERVICE string = "CONTROLLER_SERVICE"
)

// prop value enum
func (m *VersionedConnection) validateComponentTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, versionedConnectionTypeComponentTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VersionedConnection) validateComponentType(formats strfmt.Registry) error {
	if swag.IsZero(m.ComponentType) { // not required
		return nil
	}

	// value enum
	if err := m.validateComponentTypeEnum("componentType", "body", m.ComponentType); err != nil {
		return err
	}

	return nil
}

func (m *VersionedConnection) validateDestination(formats strfmt.Registry) error {
	if swag.IsZero(m.Destination) { // not required
		return nil
	}

	if m.Destination != nil {
		if err := m.Destination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

var versionedConnectionTypeLoadBalanceCompressionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DO_NOT_COMPRESS","COMPRESS_ATTRIBUTES_ONLY","COMPRESS_ATTRIBUTES_AND_CONTENT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		versionedConnectionTypeLoadBalanceCompressionPropEnum = append(versionedConnectionTypeLoadBalanceCompressionPropEnum, v)
	}
}

const (

	// VersionedConnectionLoadBalanceCompressionDONOTCOMPRESS captures enum value "DO_NOT_COMPRESS"
	VersionedConnectionLoadBalanceCompressionDONOTCOMPRESS string = "DO_NOT_COMPRESS"

	// VersionedConnectionLoadBalanceCompressionCOMPRESSATTRIBUTESONLY captures enum value "COMPRESS_ATTRIBUTES_ONLY"
	VersionedConnectionLoadBalanceCompressionCOMPRESSATTRIBUTESONLY string = "COMPRESS_ATTRIBUTES_ONLY"

	// VersionedConnectionLoadBalanceCompressionCOMPRESSATTRIBUTESANDCONTENT captures enum value "COMPRESS_ATTRIBUTES_AND_CONTENT"
	VersionedConnectionLoadBalanceCompressionCOMPRESSATTRIBUTESANDCONTENT string = "COMPRESS_ATTRIBUTES_AND_CONTENT"
)

// prop value enum
func (m *VersionedConnection) validateLoadBalanceCompressionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, versionedConnectionTypeLoadBalanceCompressionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VersionedConnection) validateLoadBalanceCompression(formats strfmt.Registry) error {
	if swag.IsZero(m.LoadBalanceCompression) { // not required
		return nil
	}

	// value enum
	if err := m.validateLoadBalanceCompressionEnum("loadBalanceCompression", "body", m.LoadBalanceCompression); err != nil {
		return err
	}

	return nil
}

var versionedConnectionTypeLoadBalanceStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DO_NOT_LOAD_BALANCE","PARTITION_BY_ATTRIBUTE","ROUND_ROBIN","SINGLE_NODE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		versionedConnectionTypeLoadBalanceStrategyPropEnum = append(versionedConnectionTypeLoadBalanceStrategyPropEnum, v)
	}
}

const (

	// VersionedConnectionLoadBalanceStrategyDONOTLOADBALANCE captures enum value "DO_NOT_LOAD_BALANCE"
	VersionedConnectionLoadBalanceStrategyDONOTLOADBALANCE string = "DO_NOT_LOAD_BALANCE"

	// VersionedConnectionLoadBalanceStrategyPARTITIONBYATTRIBUTE captures enum value "PARTITION_BY_ATTRIBUTE"
	VersionedConnectionLoadBalanceStrategyPARTITIONBYATTRIBUTE string = "PARTITION_BY_ATTRIBUTE"

	// VersionedConnectionLoadBalanceStrategyROUNDROBIN captures enum value "ROUND_ROBIN"
	VersionedConnectionLoadBalanceStrategyROUNDROBIN string = "ROUND_ROBIN"

	// VersionedConnectionLoadBalanceStrategySINGLENODE captures enum value "SINGLE_NODE"
	VersionedConnectionLoadBalanceStrategySINGLENODE string = "SINGLE_NODE"
)

// prop value enum
func (m *VersionedConnection) validateLoadBalanceStrategyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, versionedConnectionTypeLoadBalanceStrategyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VersionedConnection) validateLoadBalanceStrategy(formats strfmt.Registry) error {
	if swag.IsZero(m.LoadBalanceStrategy) { // not required
		return nil
	}

	// value enum
	if err := m.validateLoadBalanceStrategyEnum("loadBalanceStrategy", "body", m.LoadBalanceStrategy); err != nil {
		return err
	}

	return nil
}

func (m *VersionedConnection) validatePosition(formats strfmt.Registry) error {
	if swag.IsZero(m.Position) { // not required
		return nil
	}

	if m.Position != nil {
		if err := m.Position.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("position")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("position")
			}
			return err
		}
	}

	return nil
}

func (m *VersionedConnection) validateSelectedRelationships(formats strfmt.Registry) error {
	if swag.IsZero(m.SelectedRelationships) { // not required
		return nil
	}

	if err := validate.UniqueItems("selectedRelationships", "body", m.SelectedRelationships); err != nil {
		return err
	}

	return nil
}

func (m *VersionedConnection) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this versioned connection based on the context it is used
func (m *VersionedConnection) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBends(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePosition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VersionedConnection) contextValidateBends(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Bends); i++ {

		if m.Bends[i] != nil {
			if err := m.Bends[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bends" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bends" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionedConnection) contextValidateDestination(ctx context.Context, formats strfmt.Registry) error {

	if m.Destination != nil {
		if err := m.Destination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

func (m *VersionedConnection) contextValidatePosition(ctx context.Context, formats strfmt.Registry) error {

	if m.Position != nil {
		if err := m.Position.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("position")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("position")
			}
			return err
		}
	}

	return nil
}

func (m *VersionedConnection) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VersionedConnection) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VersionedConnection) UnmarshalBinary(b []byte) error {
	var res VersionedConnection
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
